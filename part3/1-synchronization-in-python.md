In this Section, we are going to take a look at
- Studying different synchronization primitives
- Using synchronization primitives to write multithread code to prevent data corruption and race
- Studying producer-consumer pattern
- Using Python Queue class for producer-consumer problem
- Multithreading in the GUI programming

In this video, we are going to take a look at
- Synchronization big picture
- Synchronization primitives
- How and when to use

# Synchronization - What and Why?
- Need for multiple threads to access shared data or resources
- Data corruption if access is not protected
- Synchronization mechanism as savior
- Example - URL Fetcher
- Python's Synchronization primitives

# Synchronization - When and How?
- Lock (acquire() and release())
- RLock (acquire() and release())
- Semaphore (acquire() and release())
- Event (set(), wait(), clear())
- Condition (acquire(), wait(), release(), notify(), notify_all())

